# Abstraction

## Overview

- EU 2.1 A variety of abstractions built on binary sequences can be used to represent all digital data.
- EU 2.2 Multiple levels of abstraction are used to write programs or create other computational artifacts.
- EU 2.3 Models and simulations use abstraction to generate new understanding and knowledge.

## Reading from the Computer Science Field Guide

Start by reading through:

- [Data Representation]('chapters:chapter' 'data-representation')
- [Software Engineering - Layers of Abstraction]('chapters:chapter_section' 'software-engineering' 'design')
- [Programming Languages]('chapters:chapter' 'programming-languages')

## Learning objectives

The above chapter readings include specific knowledge for EKs marked in bold.
Work to include unmarked learning objectives in the CS Field Guide is currently in progress.

### LO 2.1.1 Describe the variety of abstractions used to represent data.

- **EK 2.1.1A Digital data is represented by abstractions at different levels.**
- **EK 2.1.1B At the lowest level, all digital data are represented by bits.**
- **EK 2.1.1C At a higher level, bits are grouped to represent abstractions, including but not limited to numbers, characters, and color.**
- **EK 2.1.1D Number bases, including binary, decimal, and hexadecimal, are used to represent and investigate digital data.**
- **EK 2.1.1E At one of the lowest levels of abstraction, digital data is represented in binary (base 2) using only combinations of the digits zero and one.**

{panel type="teacher-note"}

# EXCLUSION STATEMENT (for EK 2.1.1E):

Twoâ€™s complement conversions are beyond the scope of this course and the AP Exam.

{panel end}

- **EK 2.1.1F Hexadecimal (base 16) is used to represent digital data because hexadecimal representation uses fewer digits than binary.**
- **EK 2.1.1G Numbers can be converted from any base to any other base.**

### LO 2.1.2 Explain how binary sequences are used to represent digital data.

- **EK 2.1.2A A finite representation is used to model the infinite mathematical concept of a number.**

{panel type="teacher-note"}

# EXCLUSION STATEMENT (for EK 2.1.2A):

Binary representations of scientific notation are beyond the scope of this course and the AP Exam.
  
{panel end}

- **EK 2.1.2B In many programming languages, the fixed number of bits used to represent characters or integers limits the range of integer values and mathematical operations; this limitation can result in over flow or other errors.**

{panel type="teacher-note"}

# EXCLUSION STATEMENT (for EK 2.1.2B):
  
Range limitations of any one language, compiler, or architecture are beyond the scope of this course and the AP Exam.

{panel end}

- EK 2.1.2C In many programming languages, the fixed number of bits used to represent real numbers (as floating-point numbers) limits the range of floating-point values and mathematical operations; this limitation can result in round off and other errors.
- **EK 2.1.2D The interpretation of a binary sequence depends on how it is used.**
- EK 2.1.2E A sequence of bits may represent instructions or data.
- **EK 2.1.2F A sequence of bits may represent different types of data in different contexts.**

### LO 2.2.1 Develop an abstraction when writing a program or creating other computational artifacts.

- EK 2.2.1A The process of developing an abstraction involves removing detail and generalizing functionality.
- EK 2.2.1B An abstraction extracts common features from specific examples in order to generalize concepts.
- EK 2.2.1C An abstraction generalizes functionality with input parameters that allow software reuse.

{panel type="teacher-note"}

# EXCLUSION STATEMENT (for EK 2.2.1C):
  
An understanding of the difference between value and reference parameters is beyond the scope of this course and the AP Exam.

{panel end}

### LO 2.2.2 Use multiple levels of abstraction to write programs.

- EK 2.2.2A Software is developed using multiple levels of abstractions, such as constants, expressions, statements, procedures, and libraries.
- EK 2.2.2B Being aware of and using multiple levels of abstraction in developing programs helps to more effectively apply available resources and tools to solve problems.

### LO 2.2.3 Identify multiple levels of abstractions that are used when writing programs.

- **EK 2.2.3A Different programming languages offer different levels of abstraction.**

{panel type="teacher-note"}

# EXCLUSION STATEMENT (for EK 2.2.3A):
  
Knowledge of the abstraction capabilities of all programming languages is beyond the scope of this course and the AP Exam.

{panel end}

- **EK 2.2.3B High-level programming languages provide more abstractions for the programmer and make it easier for people to read and write a program.**
- **EK 2.2.3C Code in a programming language is often translated into code in another (lower level) language to be executed on a computer.**
- **EK 2.2.3D In an abstraction hierarchy, higher levels of abstraction (the most general concepts) would be placed toward the top and lower level abstractions (the more specific concepts) toward the bottom.**
- EK 2.2.3E Binary data is processed by physical layers of computing hardware, including gates, chips, and components.
- EK 2.2.3F A logic gate is a hardware abstraction that is modeled by a Boolean function.

{panel type="teacher-note"}

# EXCLUSION STATEMENT (for EK 2.2.3F):
  
Memorization of specific gate visual representations is beyond the scope of this course and the AP Exam.

{panel end}

- EK 2.2.3G A chip is an abstraction composed of low-level components and circuits that perform a specific function.
- EK 2.2.3H A hardware component can be low level like a transistor or high level like a video card.
- EK 2.2.3I Hardware is built using multiple levels of abstractions, such as transistors, logic gates, chips, memory, motherboards, special purpose cards, and storage devices.
- EK 2.2.3J Applications and systems are designed, developed, and analyzed using levels of hardware, software, and conceptual abstractions.
- EK 2.2.3K Lower level abstractions can be combined to make higher level abstractions, such as short message services (SMS) or email messages, images, audio files, and videos.

### LO 2.3.1 Use models and simulations to represent phenomena.

- EK 2.3.1A Models and simulations are simplified representations of more complex objects or phenomena.
- EK 2.3.1B Models may use different abstractions or levels of abstraction depending on the objects or phenomena being posed.
- EK 2.3.1C Models often omit unnecessary features of the objects or phenomena that are being modeled.
- EK 2.3.1D Simulations mimic real-world events without the cost or danger of building and testing the phenomena in the real world.

### LO 2.3.2 Use models and simulations to formulate, refine, and test hypotheses.

- EK 2.3.2A Models and simulations facilitate the formulation and refinement of hypotheses related to the objects or phenomena under consideration.
- EK 2.3.2B Hypotheses are formulated to explain the objects or phenomena being modeled.
- EK 2.3.2C Hypotheses are refined by examining the insights that models and simulations provide into the objects or phenomena.
- EK 2.3.2D The results of simulations may generate new knowledge and new hypotheses related to the phenomena being modeled.
- EK 2.3.2E Simulations allow hypotheses to be tested without the constraints of the real world.
- EK 2.3.2F Simulations can facilitate extensive and rapid testing of models.
- EK 2.3.2G The time required for simulations is impacted by the level of detail and quality of the models and the software and hardware used for the simulation.
- EK 2.3.2H Rapid and extensive testing allows models to be changed to accurately reflect the objects or phenomena being modeled.
